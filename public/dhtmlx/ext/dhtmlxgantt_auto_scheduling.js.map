{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./sources/core/relations/links_builder.js","webpack://[name]/./sources/utils/helpers.js","webpack://[name]/./sources/ext/auto_scheduling/constraint_types.ts","webpack://[name]/./sources/core/relations/graph_helper.js","webpack://[name]/./sources/core/relations/links_common.js","webpack://[name]/./sources/ext/auto_scheduling/ui_handlers.ts","webpack://[name]/./sources/ext/auto_scheduling/loops_finder.ts","webpack://[name]/./sources/ext/auto_scheduling/connected_groups.ts","webpack://[name]/./sources/ext/auto_scheduling/asap_strategy.ts","webpack://[name]/./sources/ext/auto_scheduling/alap_strategy.ts","webpack://[name]/./sources/ext/auto_scheduling/planner.ts","webpack://[name]/./sources/ext/auto_scheduling/constraints.ts","webpack://[name]/./sources/ext/auto_scheduling.js","webpack://[name]/./sources/ext/auto_scheduling/task_plan.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","gantt","getVirtualRoot","mixin","getSubtaskDates","id","config","root_id","type","types","project","$source","$target","$virtual","getLinkedTasks","includePredecessors","startIds","clearCache","_isLinksCacheEnabled","_startLinksCache","relations","visited","result","length","this","_getLinkedTasks","push","_endLinksCache","_collectRelations","rootObj","isChild","visitedLinks","linkKey","successors","_getSuccessors","predecessors","_getPredecessors","hashSum","rootTask","visitedTasks","output","from","undefined","tasksStack","current","pop","isTaskExists","getTask","rel","isSameParent","sourceParent","targetParent","target","hasChild","children","getChildren","units","second","minute","hour","day","week","month","quarter","year","arrayFilter","arr","callback","filter","getSecondsInUnit","unit","forEach","workArray","slice","arrayMap","map","resArray","arrayFind","find","arrayDifference","item","arraySome","hashToArray","hash","sortArrayOfHash","field","desc","compare","a","b","sort","throttle","timeout","wait","apply","arguments","setTimeout","isArray","obj","Array","isDate","getFullYear","getMonth","getDate","isStringObject","Function","toString","constructor","isNumberObject","isBooleanObject","delay","timer","$cancelTimeout","$pending","args","clearTimeout","$execute","objectKeys","keys","requestAnimationFrame","w","webkitRequestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","cb","isEventable","attachEvent","detachEvent","ConstraintTypes","helpers","getVertices","ids","len","source","vertices","topologicalSort","edges","$incoming","successor","S","v","L","node","groupAdjacentEdges","edge","res","tarjanStronglyConnectedComponents","verticesHash","stack","edgesFromTasks","recurse","connectedComponents","getVertex","workStack","index","lowLink","onStack","e","Math","min","com","tasks","links","findLoops","cycles","component","_get_linked_task","link","getTarget","task","taskId","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_formatLink","isSummaryTask","isChildOf","_getImplicitLinks","respectTargetOffset","auto_scheduling_move_projects","targetDates","start_date","end_date","to","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","parent","selectOffset","selectSourceLinks","skipChild","eachTask","linksCollection","siblingLink","getLink","siblingId","siblingTask","abs","duration","_getDirectDependencies","selectSuccessors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","eachParent","parentDependencies","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","skipInherited","String","sourceTask","targetTask","finish_to_start","preferredStart","additionalLag","start_to_start","finish_to_finish","start_to_finish","attachUIHandlers","linksBuilder","loopsFinder","connectedGroupsHelper","_attachAutoSchedulingHandlers","movedTask","_scheduleAfterBatchUpdate","_autoScheduleAfterLinkChange","_autoscheduling_in_progress","batch_update","autoSchedule","_preventCircularLink","isCircularLink","callEvent","getLoopContainingLink","_preventDescendantLink","auto_scheduling_descendant_links","_datesNotEqual","dateA","dateB","taskA","taskB","valueOf","_hasDuration","_notEqualTaskDates","task1","task2","getConstraintType","constraint_date","milestone","getRelations","auto_scheduling_compatibility","getConnectedGroupRelations","updateTaskConstraints","schedule_from_end","constraint_type","constraint_types","FNLT","Date","SNET","finalizeTaskConstraints","auto_scheduling_strict","auto_scheduling_initial","changedConstraint","_autoScheduleAfterDND","newTask","relationsArray","skipped","originalLink","splice","presentLinks","updatedLinks","resetToStartLinksLags","_autoSchedule","modifiedTaskId","ext","inlineEditors","autoscheduleColumns_1","state","columnName","editorConfig","getEditorConfig","map_to","oldTask","LoopsFinder","graphHelper","_this","_graphHelper","_linksBuilder","_gantt","allRelations","isLinkExists","findCycles","breadthFirstSearch","currentVertex","queue","groupTasks","groupLinksInternal","groupLinksPublic","shift","linksArray","linksObjects","processedLinks","ConnectedGroupsHelper","getConnectedGroup","group","groups","length_1","findGroups","task_plan_1","AsapStrategy","Create","instance","resolveRelationDate","adjacentLinks","plansHash","minStart","linkId","defaultStart","minRelationDate","relation","constraintDate","getEarliestStartDate","isSmallerOrDefault","project_start","maxEnd","getClosestWorkTime","date","dir","calculateEndDate","masterPlan","currentPlan","TaskPlan","kind","earliestSchedulingStart","earliestSchedulingEnd","isEqual","isFirstSmaller","small","big","smallDate","bigDate","getPredecessorEndDate","plan","predecessorEnd","successorStart","AlapStrategy","maxStart","maxRelationDate","getLatestEndDate","constraintStartDate","isGreaterOrDefault","project_end","latestSchedulingStart","latestSchedulingEnd","getSuccessorStartDate","predecessor","alap_strategy_1","asap_strategy_1","constraint_types_1","AutoSchedulingPlanner","constraintsHelper","_constraintsHelper","_asapStrategy","_alapStrategy","generatePlan","constraints","alapStrategy","asapStrategy","_a","buildWorkCollections","orderedIds","reversedIds","relationsMap","processConstraints","iterateTasks","isAlapTask","isAsapTask","applyProjectPlan","projectPlan","reason","updateTasks","newDate","mainSequence","secondarySequence","isMainSequence","mainSequenceStrategy","secondarySequenceStrategy","currentId","limitPlanDates","processResolvedDate","effectiveStart","earliestStart","earliestEnd","latestStart","latestEnd","conflict","reverse","unshift","constraintType","ASAP","ALAP","processConstraint","ConstraintsHelper","hasConstraint","newPlan","SNLT","FNET","MSO","MFO","getConstraints","store","planner","connectedGroups","getConstraintLimitations","updatedTasks","startTask","preferInitialTaskDates","batchUpdate","payload","updateTask","resetTime","start","end","resetProjectDates","updateParentsAndCallEvents","inclusive","auto_scheduling_compatible","parseDate"],"mappings":"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","file":"ext/dhtmlxgantt_auto_scheduling.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ext/dhtmlxgantt_auto_scheduling\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ext/dhtmlxgantt_auto_scheduling\"] = factory();\n\telse\n\t\troot[\"ext/dhtmlxgantt_auto_scheduling\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/codebase/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 269);\n","module.exports = function(gantt) {\n\treturn {\n\t\tgetVirtualRoot: function(){\n\t\t\treturn gantt.mixin(\n\t\t\t\tgantt.getSubtaskDates(),\n\t\t\t\t{\n\t\t\t\t\tid: gantt.config.root_id,\n\t\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t\t$source: [],\n\t\t\t\t\t$target: [],\n\t\t\t\t\t$virtual: true\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\n\t\tgetLinkedTasks: function(id, includePredecessors){\n\t\t\tvar startIds = [id];\n\t\n\t\t\t//TODO: format links cache\n\t\t\tvar clearCache = false;\n\t\t\tif(!gantt._isLinksCacheEnabled()) {\n\t\t\t\tgantt._startLinksCache();\n\t\t\t\tclearCache = true;\n\t\t\t}\n\t\t\tvar relations = [];\n\t\t\tvar visited = {};\n\t\t\tvar result = {};\n\t\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors, result);\n\t\t\t}\n\t\n\t\t\tfor(var i in result){\n\t\t\t\trelations.push(result[i]);\n\t\t\t}\n\t\n\t\t\t//TODO: remove redundant edges before continue https://en.wikipedia.org/wiki/Transitive_reduction\n\t\t\tif(clearCache)\n\t\t\t\tgantt._endLinksCache();\n\t\t\treturn relations;\n\t\t},\n\t\n\t\t_collectRelations: function(rootObj, isChild, includePredecessors, visitedLinks){\n\t\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\n\t\n\t\t\tvar predecessors = [];\n\t\t\tif (includePredecessors) {\n\t\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\n\t\t\t}\n\t\t\t\n\t\t\tvar linkKey;\n\t\t\tvar relations = [];\n\t\t\tfor(var i = 0; i < successors.length; i++){\n\t\t\t\tlinkKey = successors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(successors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var i = 0; i < predecessors.length; i++){\n\t\t\t\tlinkKey = predecessors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(predecessors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn relations;\n\t\t},\n\t\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, output) {\n\t\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\t\tvar visitedTasks = {};\n\t\t\tvar visitedLinks = {};\n\t\t\tvar rootObj;\n\t\n\t\t\tvar tasksStack = [{from: from, includePredecessors: includePredecessors, isChild:false}];\n\t\n\t\t\twhile(tasksStack.length){\n\t\t\t\tvar current = tasksStack.pop();\n\t\t\t\tvar isChild = current.isChild;\n\t\n\t\t\t\tfrom = current.from;\n\t\t\t\tif(visitedTasks[from]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\t\t\tvisitedTasks[from] = true;\n\t\t\t\t\n\t\t\t\tvar relations = this._collectRelations(rootObj, isChild, includePredecessors, visitedLinks);\n\t\n\t\t\t\tfor(var i=0; i < relations.length; i++){\n\t\t\t\t\tvar rel = relations[i];\n\t\t\t\t\toutput[rel.hashSum] = rel;\n\t\t\t\t\tvar isSameParent = rel.sourceParent == rel.targetParent;\n\t\t\t\t\tvar targetTask = rel.target;\n\t\t\t\t\tif(!visitedTasks[targetTask])\n\t\t\t\t\t\ttasksStack.push({from: rel.target, includePredecessors: true, isChild: isSameParent});\n\t\t\t\t}\n\t\n\t\t\t\tif(gantt.hasChild(rootObj.id)){\n\t\t\t\t\tvar children = gantt.getChildren(rootObj.id);\n\t\t\t\t\tfor(var i=0; i < children.length; i++){\n\t\t\t\t\t\tif(!visitedTasks[children[i]])\n\t\t\t\t\t\t\ttasksStack.push({from: children[i], includePredecessors: true, isChild: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn output;\n\t\t}\n\t};\n};","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback) {\n\tif (arr.forEach) {\n\t\tarr.forEach(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tcallback(workArray[i], i);\n\t\t}\n\t}\n}\n\nfunction arrayMap(arr, callback) {\n\tif (arr.map) {\n\t\treturn arr.map(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tvar resArray = [];\n\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tresArray.push(callback(workArray[i], i));\n\t\t}\n\t\treturn resArray;\n\t}\n}\n\n\nfunction arrayFind(arr, callback) {\n\tif (arr.find) {\n\t\treturn arr.find(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// iframe-safe array type check instead of using instanceof\nfunction isArray(obj){\n\tif(Array.isArray){\n\t\treturn Array.isArray(obj);\n\t}else{\n\t\t// close enough\n\t\treturn (obj && obj.length !== undefined && obj.pop && obj.push);\n\t}\n}\n\n// non-primitive string object, e.g. new String(\"abc\")\nfunction isStringObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function String() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Number(5)\nfunction isNumberObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Number() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Boolean(true)\nfunction isBooleanObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Boolean() { [native code] }\";\n}\n\nfunction isDate(obj) {\n\tif (obj && typeof obj === \"object\") {\n\t\treturn !!(obj.getFullYear && obj.getMonth && obj.getDate);\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction arrayFilter(arr, callback) {\n\tvar result = [];\n\n\tif (arr.filter) {\n\t\treturn arr.filter(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\tresult[result.length] = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction hashToArray(hash) {\n\tvar result = [];\n\n\tfor (var key in hash) {\n\t\tif (hash.hasOwnProperty(key)) {\n\t\t\tresult.push(hash[key]);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction arraySome(arr, callback) {\n\tif (arr.length === 0) return false;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (callback(arr[i], i, arr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction arrayDifference(arr, callback) {\n\treturn arrayFilter(arr, function(item, i) {\n\t\treturn !callback(item, i);\n\t});\n}\n\nfunction throttle (callback, timeout) {\n\tvar wait = false;\n\n\treturn function () {\n\t\tif (!wait) {\n\t\t\tcallback.apply(null, arguments);\n\t\t\twait = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\twait = false;\n\t\t\t}, timeout);\n\t\t}\n\t};\n}\n\nfunction delay (callback, timeout){\n\tvar timer;\n\n\tvar result = function() {\n\t\tresult.$cancelTimeout();\n\t\tcallback.$pending = true;\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\ttimer = setTimeout(function(){\n\t\t\tcallback.apply(this, args);\n\t\t\tresult.$pending = false;\n\t\t}, timeout);\n\t};\n\t\n\tresult.$pending = false;\n\tresult.$cancelTimeout = function(){\n\t\tclearTimeout(timer);\n\t\tcallback.$pending = false;\n\t};\n\tresult.$execute = function(){\n\t\tcallback();\n\t\tcallback.$cancelTimeout();\n\t};\n\n\treturn result;\n}\n\nfunction sortArrayOfHash(arr, field, desc) {\n\tvar compare = function(a, b) {\n\t\treturn a < b;\n\t};\n\n\tarr.sort(function(a, b) {\n\t\tif (a[field] === b[field]) return 0;\n\n\t\treturn desc ? compare(a[field], b[field]) : compare(b[field], a[field]);\n\t});\n}\n\nfunction objectKeys(obj) {\n\tif (Object.keys) {\n\t\treturn Object.keys(obj);\n\t}\n\tvar result = [];\n\tvar key;\n\tfor (key in obj) {\n\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\tresult.push(key);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction requestAnimationFrame(callback) {\n\tvar w = window;\n\tvar foundRequestAnimationFrame = w.requestAnimationFrame\n\t\t|| w.webkitRequestAnimationFrame\n\t\t|| w.msRequestAnimationFrame\n\t\t|| w.mozRequestAnimationFrame\n\t\t|| w.oRequestAnimationFrame\n\t\t|| function(cb) { setTimeout(cb, 1000/60); };\n\treturn foundRequestAnimationFrame(callback);\n}\n\nfunction isEventable(obj) {\n\treturn obj.attachEvent && obj.detachEvent;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap,\n\tarrayFind: arrayFind,\n\tarrayFilter: arrayFilter,\n\tarrayDifference: arrayDifference,\n\tarraySome: arraySome,\n\thashToArray: hashToArray,\n\tsortArrayOfHash: sortArrayOfHash,\n\tthrottle: throttle,\n\tisArray: isArray,\n\tisDate: isDate,\n\tisStringObject: isStringObject,\n\tisNumberObject: isNumberObject,\n\tisBooleanObject: isBooleanObject,\n\tdelay: delay,\n\tobjectKeys: objectKeys,\n\trequestAnimationFrame: requestAnimationFrame,\n\tisEventable: isEventable\n};","export enum ConstraintTypes {\n\t// As Soon As Possible (ASAP)\n\tASAP = \"asap\",\n\t// As Late As Possible (ALAP)\n\tALAP = \"alap\",\n\t// Start No Earlier Than (SNET)\n\tSNET = \"snet\",\n\t// Start No Later Than (SNLT)\n\tSNLT = \"snlt\",\n\t// Finish No Earlier Than (FNET)\n\tFNET = \"fnet\",\n\t// Finish No Later Than (FNLT)\n\tFNLT = \"fnlt\",\n\t// Must Start On (MSO)\n\tMSO = \"mso\",\n\t// Must Finish On (MFO)\n\tMFO = \"mfo\"\n}","var helpers = require(\"../../utils/helpers\");\n\nmodule.exports = function(){\n\treturn {\n\t\tgetVertices: function(relations){\n\t\t\tvar ids = {};\n\t\t\tvar rel;\n\t\t\tfor(var i = 0, len = relations.length; i < len; i++){\n\t\t\t\trel = relations[i];\n\t\t\t\tids[rel.target] = rel.target;\n\t\t\t\tids[rel.source] = rel.source;\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\t\t\tvar id;\n\t\t\tfor(var i in ids){\n\t\t\t\tid = ids[i];\n\t\t\t\tvertices.push(id);\n\t\t\t}\n\n\t\t\treturn vertices;\n\t\t},\n\t\ttopologicalSort: function(edges){\n\t\t\tvar vertices = this.getVertices(edges);\n\t\t\tvar hash = {};\n\n\t\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\n\t\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tvar successor = hash[edges[i].target];\n\t\t\t\tsuccessor.$target.push(i);\n\t\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t\t}\n\n\t\t\t// topological sort, Kahn's algorithm\n\t\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\t\tvar L = [];\n\n\t\t\twhile(S.length){\n\t\t\t\tvar n = S.pop();\n\n\t\t\t\tL.push(n);\n\n\t\t\t\tvar node = hash[n];\n\n\t\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\t\tm.$incoming--;\n\t\t\t\t\tif(!m.$incoming){\n\t\t\t\t\t\tS.push(m.id);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn L;\n\n\t\t},\n\t\tgroupAdjacentEdges: function(edges){\n\t\t\tvar res = {};\n\t\t\tvar edge;\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tedge = edges[i];\n\t\t\t\tif(!res[edge.source]){\n\t\t\t\t\tres[edge.source] = [];\n\t\t\t\t}\n\t\t\t\tres[edge.source].push(edge);\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\t\t// iterative implementation\n\t\t\tvar verticesHash = {};\n\t\t\tvar stack = [];\n\t\t\tvar edgesFromTasks = this.groupAdjacentEdges(edges);\n\t\t\tvar recurse = false;\n\t\t\tvar connectedComponents = [];\n\n\t\t\tfor(var i = 0; i < vertices.length; i++){\n\t\t\t\tvar root = getVertex(vertices[i]);\n\t\t\t\tif(root.visited) continue;\n\t\t\t\tvar workStack = [root];\n\t\t\t\tvar index = 0;\n\t\t\t\twhile(workStack.length){\n\t\t\t\t\tvar v = workStack.pop();\n\n\t\t\t\t\tif(!v.visited){\n\t\t\t\t\t\tv.index = index;\n\t\t\t\t\t\tv.lowLink = index;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tstack.push(v);\n\t\t\t\t\t\tv.onStack = true;\n\t\t\t\t\t\tv.visited = true;\n\t\t\t\t\t}\n\t\t\t\t\trecurse = false;\n\t\t\t\t\tvar edges = edgesFromTasks[v.id] || [];\n\t\t\t\t\tfor(var e = 0; e < edges.length; e++){\n\t\t\t\t\t\tvar w = getVertex(edges[e].target);\n\t\t\t\t\t\tw.edge = edges[e];\n\t\t\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t\t\tworkStack.push(v);\n\t\t\t\t\t\t\tworkStack.push(w);\n\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(recurse)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (v.index == v.lowLink){\n\t\t\t\t\t\tvar com = {tasks:[], links:[]};\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tw = stack.pop();\n\t\t\t\t\t\t\tw.onStack = false;\n\t\t\t\t\t\t\tcom.tasks.push(w.id);\n\t\t\t\t\t\t\tif(w.edge){\n\t\t\t\t\t\t\t\tcom.links.push(w.edge.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(w == v){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconnectedComponents.push(com);\n\t\t\t\t\t}\n\t\t\t\t\tif(workStack.length){\n\t\t\t\t\t\tw = v;\n\t\t\t\t\t\tv = workStack[workStack.length - 1];\n\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn connectedComponents;\n\n\t\t\tfunction getVertex(id){\n\t\t\t\tif(!verticesHash[id]){\n\t\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined, edge: undefined};\n\t\t\t\t}\n\n\t\t\t\treturn verticesHash[id];\n\t\t\t}\n\t\t},\n\n\t\tfindLoops: function(relations){\n\t\t\tvar cycles = [];\n\n\t\t\thelpers.forEach(relations, function(rel){\n\t\t\t\tif(rel.target == rel.source)\n\t\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t\t});\n\n\t\t\tvar vertices = this.getVertices(relations);\n\n\t\t\tvar connectedComponents = this.tarjanStronglyConnectedComponents(vertices, relations);\n\t\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\t\tif(component.tasks.length > 1){\n\t\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn cycles;\n\t\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t\t}\n\t};\n};","module.exports = function (gantt) {\n\t// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\tvar caching = false;\n\tvar formattedLinksStash = {};\n\tvar inheritedSuccessorsStash = {};\n\tvar inheritedPredecessorsStash = {};\n\tvar getPredecessorsCache = {};\n\n\n\tgantt._isLinksCacheEnabled = function () {\n\t\treturn caching;\n\t};\n\tgantt._startLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = true;\n\t};\n\tgantt._endLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = false;\n\t};\n\n\tgantt._formatLink = function (link) {\n\n\n\t\tif (caching && formattedLinksStash[link.id]) {\n\t\t\treturn formattedLinksStash[link.id];\n\t\t}\n\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\n\t\t\treturn relations;\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t}, true);\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\n\t\t\t}\n\t\t}\n\n\t\tif (caching)\n\t\t\tformattedLinksStash[link.id] = relations;\n\n\t\treturn relations;\n\t};\n\n\tgantt._isAutoSchedulable = function (task) {\n\t\treturn task.auto_scheduling !== false;\n\t};\n\n\tgantt._getImplicitLinks = function (link, parent, selectOffset, selectSourceLinks) {\n\t\tvar relations = [];\n\n\t\tif (this.isSummaryTask(parent)) {\n\n\t\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\n\t\t\t// it will be enough to check the first/last tasks of the chain\n\t\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values that put the end date of the successor task prior to its predecessors' date\n\t\t\tvar children = {};\n\t\t\tthis.eachTask(function (c) {\n\t\t\t\tif (!this.isSummaryTask(c)) {\n\t\t\t\t\tchildren[c.id] = c;\n\t\t\t\t}\n\t\t\t}, parent.id);\n\n\t\t\tvar skipChild;\n\n\t\t\tfor (var c in children) {\n\t\t\t\tvar task = children[c];\n\t\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\n\n\t\t\t\tskipChild = false;\n\n\t\t\t\tfor (var l = 0; l < linksCollection.length; l++) {\n\t\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\n\t\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\n\t\t\t\t\tvar siblingTask = children[siblingId];\n\t\t\t\t\tif (siblingTask && task.auto_scheduling !== false && siblingTask.auto_scheduling !== false) {\n\t\t\t\t\t\tif ((siblingLink.target == siblingTask.id && Math.abs(siblingLink.lag) <= siblingTask.duration) ||\n\t\t\t\t\t\t\t(siblingLink.target == task.id && Math.abs(siblingLink.lag) <= task.duration)) {\n\t\t\t\t\t\t\tskipChild = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skipChild) {\n\t\t\t\t\trelations.push({ task: task.id, taskParent: task.parent, lag: selectOffset(task) });\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\trelations.push({ task: parent.id, taskParent: parent.parent, lag: 0 });\n\t\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\t\tfor (var i = 0; i < linksIds.length; i++) {\n\t\t\tvar link = this.getLink(linksIds[i]);\n\t\t\tif (this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\t\tvar target = this.getTask(link.target);\n\t\t\t\tif (this._isAutoSchedulable(target)) {\n\t\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\n\t\t//var successors = [];\n\t\tvar stop = false;\n\t\tvar inheritedRelations = [];\n\t\tvar cacheCollection;\n\t\tif (this.isTaskExists(task.id)) {\n\t\t\tthis.eachParent(function (parent) {\n\t\t\t\tif (stop)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (caching) {\n\t\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\n\t\t\t\t\tif (cacheCollection[parent.id]) {\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(cacheCollection[parent.id]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar parentDependencies;\n\t\t\t\tif (this.isSummaryTask(parent)) {\n\t\t\t\t\tif (!this._isAutoSchedulable(parent)) {\n\t\t\t\t\t\tstop = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\n\t\t\t\t\t\tif (caching) {\n\t\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(parentDependencies);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}, task.id, this);\n\t\t}\n\n\t\treturn inheritedRelations;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\tgantt._getSuccessors = function (task, skipInherited) {\n\t\tvar successors = this._getDirectSuccessors(task);\n\t\tif (skipInherited) {\n\t\t\treturn successors;\n\t\t} else {\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\n\t\t}\n\t};\n\n\tgantt._getPredecessors = function (task, skipInherited) {\n\t\tvar key = String(task.id) + \"-\" + String(skipInherited);\n\t\tvar result;\n\n\t\tif (caching && getPredecessorsCache[key]) {\n\t\t\treturn getPredecessorsCache[key];\n\t\t}\n\n\t\tvar predecessors = this._getDirectPredecessors(task);\n\t\tif (skipInherited) {\n\t\t\tresult = predecessors;\n\t\t} else {\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\n\t\t}\n\t\tif (caching) {\n\t\t\tgetPredecessorsCache[key] = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null,\n\t\t\tsourceParent: sourceParent,\n\t\t\ttargetParent: targetParent,\n\t\t\thashSum: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\tres.hashSum = res.lag + \"_\" + res.link + \"_\" + res.source + \"_\" + res.target;\n\t\treturn res;\n\t};\n};","import { ConnectedGroupsHelper } from \"./connected_groups\";\n\nexport function attachUIHandlers(\n\tgantt: any,\n\tlinksBuilder: any,\n\tloopsFinder: any,\n\tconnectedGroupsHelper: ConnectedGroupsHelper\n) {\n\tlet _attachAutoSchedulingHandlers = function() {\n\t\tlet _scheduleAfterBatchUpdate = false;\n\t\tgantt.attachEvent(\"onAfterBatchUpdate\", function(){\n\n\t\t\tif(_scheduleAfterBatchUpdate){\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t\t_scheduleAfterBatchUpdate = false;\n\t\t});\n\n\t\tfunction _autoScheduleAfterLinkChange(id: LinkID, link: ILink) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif(gantt.getState().batch_update){\n\t\t\t\t\t_scheduleAfterBatchUpdate = true;\n\t\t\t\t}else{\n\t\t\t\t\tgantt.autoSchedule(link.source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgantt.attachEvent(\"onAfterLinkUpdate\", _autoScheduleAfterLinkChange);\n\t\tgantt.attachEvent(\"onAfterLinkAdd\", _autoScheduleAfterLinkChange);\n\n\t\tgantt.attachEvent(\"onAfterLinkDelete\", function(id: LinkID, link: ILink) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\t!gantt._autoscheduling_in_progress &&\n\t\t\t\tgantt.isTaskExists(link.target)\n\t\t\t) {\n\t\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\t\tconst target = gantt.getTask(link.target);\n\t\t\t\tconst predecessors = gantt._getPredecessors(target);\n\t\t\t\tif (predecessors.length) {\n\t\t\t\t\tif(gantt.getState().batch_update){\n\t\t\t\t\t\t_scheduleAfterBatchUpdate = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgantt.autoSchedule(predecessors[0].source, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tgantt.attachEvent(\"onParse\", function() {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_initial\n\t\t\t) {\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t});\n\n\t\tfunction _preventCircularLink(id: LinkID, link: ILink): boolean {\n\t\t\tif (gantt.isCircularLink(link)) {\n\t\t\t\tgantt.callEvent(\"onCircularLinkError\", [\n\t\t\t\t\tlink,\n\t\t\t\t\tloopsFinder.getLoopContainingLink(link)\n\t\t\t\t]);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction _preventDescendantLink(id: LinkID, link: ILink): boolean {\n\t\t\tconst source = gantt.getTask(link.source);\n\t\t\tconst target = gantt.getTask(link.target);\n\n\t\t\tif (!gantt.config.auto_scheduling_descendant_links) {\n\t\t\t\tif (\n\t\t\t\t\t(gantt.isChildOf(source.id, target.id) &&\n\t\t\t\t\t\tgantt.isSummaryTask(target)) ||\n\t\t\t\t\t(gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventDescendantLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventDescendantLink);\n\n\t\tfunction _datesNotEqual(\n\t\t\tdateA: Date,\n\t\t\tdateB: Date,\n\t\t\ttaskA: ITask,\n\t\t\ttaskB: ITask\n\t\t): boolean {\n\t\t\tif (!!dateA !== !!dateB) {\n\t\t\t\t// if one of dates is empty or null and the other is not\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!dateA && !dateB) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (dateA.valueOf() > dateB.valueOf()) {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateB,\n\t\t\t\t\tend_date: dateA,\n\t\t\t\t\ttask: taskB\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateA,\n\t\t\t\t\tend_date: dateB,\n\t\t\t\t\ttask: taskA\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfunction _notEqualTaskDates(task1: ITask, task2: ITask): boolean {\n\t\t\tif (_datesNotEqual(task1.start_date, task2.start_date, task1, task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (gantt.getConstraintType(task1) !== gantt.getConstraintType(task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(\n\t\t\t\t\ttask1.constraint_date,\n\t\t\t\t\ttask2.constraint_date,\n\t\t\t\t\ttask1,\n\t\t\t\t\ttask2\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t\t((_datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\t\ttask1.duration !== task2.duration) &&\n\t\t\t\t\ttask1.type !== gantt.config.types.milestone)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getRelations(id: TaskID) {\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility) {\n\t\t\t\t// collect only downstream dependencies since there is no backward or ALAP scheduling in pre 6.1 auto scheduling\n\t\t\t\treturn linksBuilder.getLinkedTasks(id, true);\n\t\t\t} else {\n\t\t\t\t// get all connected group (both upstream and downstream dependencies)\n\t\t\t\treturn connectedGroupsHelper.getConnectedGroupRelations(id);\n\t\t\t}\n\t\t}\n\n\t\tlet relations;\n\t\tlet movedTask;\n\t\tgantt.attachEvent(\"onBeforeTaskDrag\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_move_projects\n\t\t\t) {\n\t\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\t\trelations = getRelations(id);\n\n\t\t\t\tmovedTask = id;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\tfunction resetToStartLinksLags(taskId, relationsArray) {\n\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish_to_start links\n\t\t\t// recalculate these links if task duration has changed\n\n\t\t\tlet skipped = false;\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst originalLink = gantt.getLink(relationsArray[i].id);\n\t\t\t\tif (\n\t\t\t\t\toriginalLink &&\n\t\t\t\t\t(originalLink.type === gantt.config.links.start_to_start ||\n\t\t\t\t\t\toriginalLink.type === gantt.config.links.start_to_finish)\n\t\t\t\t) {\n\t\t\t\t\trelationsArray.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tskipped = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skipped) {\n\t\t\t\tconst presentLinks = {};\n\t\t\t\tfor (let i = 0; i < relationsArray.length; i++) {\n\t\t\t\t\tpresentLinks[relationsArray[i].id] = true;\n\t\t\t\t}\n\n\t\t\t\tconst updatedLinks = getRelations(taskId);\n\n\t\t\t\tfor (let i = 0; i < updatedLinks.length; i++) {\n\t\t\t\t\tif (!presentLinks[updatedLinks[i].id]) {\n\t\t\t\t\t\trelationsArray.push(updatedLinks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateTaskConstraints(task){\n\t\t\tif (gantt.config.schedule_from_end) {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.FNLT;\n\t\t\t\ttask.constraint_date = new Date(task.end_date);\n\t\t\t} else {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.SNET;\n\t\t\t\ttask.constraint_date = new Date(task.start_date);\n\t\t\t}\n\t\t}\n\n\t\tfunction finalizeTaskConstraints(task){\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility && gantt.config.auto_scheduling_strict) {\n\t\t\t\tif (task.constraint_type === gantt.config.constraint_types.SNET ||\n\t\t\t\t\ttask.constraint_type === gantt.config.constraint_types.FNLT) {\n\t\t\t\t\t\ttask.constraint_type = null;\n\t\t\t\t\t\ttask.constraint_date = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst _autoScheduleAfterDND = function(taskId, task) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tconst newTask = gantt.getTask(taskId);\n\n\t\t\t\tif (_notEqualTaskDates(task, newTask)) {\n\t\t\t\t\tupdateTaskConstraints(newTask);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tgantt.config.auto_scheduling_move_projects &&\n\t\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\t\tmovedTask == taskId\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgantt.calculateDuration(task) !== gantt.calculateDuration(newTask)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgantt._autoSchedule(taskId, relations);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalizeTaskConstraints(newTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\trelations = null;\n\t\t\tmovedTask = null;\n\t\t\treturn true;\n\t\t};\n\n\n\n\n\t\tlet modifiedTaskId = null;\n\t\tif (gantt.ext && gantt.ext.inlineEditors) {\n\t\t\tconst inlineEditors = gantt.ext.inlineEditors;\n\t\t\tconst autoscheduleColumns = {\n\t\t\t\tstart_date: true,\n\t\t\t\tend_date: true,\n\t\t\t\tduration: true,\n\t\t\t\tconstraint_type: true,\n\t\t\t\tconstraint_date: true\n\t\t\t};\n\n\t\t\tinlineEditors.attachEvent(\"onBeforeSave\", function(state) {\n\t\t\t\tif (autoscheduleColumns[state.columnName]) {\n\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tlet changedConstraint;\n\t\tfunction onBeforeLigthboxSaveHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tchangedConstraint = false;\n\t\t\t\tconst oldTask = gantt.getTask(taskId);\n\t\t\t\tif (_notEqualTaskDates(task, oldTask)) {\n\t\t\t\t\tmodifiedTaskId = taskId;\n\t\t\t\t\tif(gantt.getConstraintType(task) !== gantt.getConstraintType(oldTask) ||\n\t\t\t\t\t\t+task.constraint_date !== +oldTask.constraint_date\n\t\t\t\t\t){\n\t\t\t\t\t\tchangedConstraint = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction onAfterTaskUpdateHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif (\n\t\t\t\t\tmodifiedTaskId &&\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\tmodifiedTaskId == taskId\n\t\t\t\t) {\n\t\t\t\t\tmodifiedTaskId = null;\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tupdateTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t\tgantt.autoSchedule(task.id);\n\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tfinalizeTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeTaskChanged\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\treturn _autoScheduleAfterDND(id, task);\n\t\t});\n\n\t\tif(gantt.ext.inlineEditors){\n\t\t\tgantt.ext.inlineEditors.attachEvent(\"onBeforeSave\", function(state){\n\t\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\t\tconst api = gantt.ext.inlineEditors;\n\t\t\t\t\tconst editorConfig = api.getEditorConfig(state.columnName);\n\t\t\t\t\tif(editorConfig.map_to === \"start_date\" || editorConfig.map_to === \"end_date\" || editorConfig.map_to === \"duration\"){\n\t\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tgantt.attachEvent(\"onLightboxSave\", onBeforeLigthboxSaveHandler);\n\t\tgantt.attachEvent(\"onAfterTaskUpdate\", onAfterTaskUpdateHandler);\n\t};\n\n\tgantt.attachEvent(\"onGanttReady\", function() {\n\t\t_attachAutoSchedulingHandlers();\n\t\t// attach handlers only when initialized for the first time\n\t\t_attachAutoSchedulingHandlers = function() { };\n\t});\n}\n","export class LoopsFinder {\n\tprivate _linksBuilder: any;\n\tprivate _graphHelper: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, graphHelper: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._gantt = gantt;\n\t}\n\tisCircularLink = (link: ILink): boolean => {\n\t\treturn !!this.getLoopContainingLink(link);\n\t}\n\n\tgetLoopContainingLink = (link: ILink): any => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\t\tconst gantt = this._gantt;\n\n\t\tlet allRelations = linksBuilder.getLinkedTasks();\n\t\tif (!gantt.isLinkExists(link.id)) {\n\t\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t\t}\n\n\t\tconst cycles = graphHelper.findLoops(allRelations);\n\n\t\tconst found = false;\n\t\tfor (let i = 0; i < cycles.length && !found; i++) {\n\t\t\tconst links = cycles[i].links;\n\t\t\tfor (let j = 0; j < links.length; j++) {\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif (links[j] == link.id) {\n\t\t\t\t\treturn cycles[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindCycles = () => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\n\t\tconst allRelations = linksBuilder.getLinkedTasks();\n\t\treturn graphHelper.findLoops(allRelations);\n\t}\n}\n","interface IFlagHash {\n\t[id: string]: boolean;\n}\n\nfunction findGroups(links: IInternalLink[]): IConnectedGroup[] {\n\tconst visited: IFlagHash = {};\n\tconst groups = [];\n\tlet source: TaskID;\n\tlet target: TaskID;\n\tlet root: TaskID;\n\t// main loop - find any unvisited vertex from the input array and\n\t// treat it as the source, then perform a breadth first search from\n\t// it. All vertices visited from this search belong to the same group\n\tfor (let i = 0; i < links.length; i++) {\n\t\tsource = links[i].source;\n\t\ttarget = links[i].target;\n\t\troot = null;\n\t\tif (!visited[source]) {\n\t\t\troot = source;\n\t\t} else if (!visited[target]) {\n\t\t\troot = target;\n\t\t}\n\t\tif (root) {\n\t\t\t// there is an unvisited vertex in this pair.\n\t\t\t// perform a breadth first search, and push the resulting\n\t\t\t// group onto the list of all groups\n\t\t\tconst length = links.length;\n\t\t\tgroups.push(breadthFirstSearch(root, links, visited));\n\t\t\tif (length !== links.length) {\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn groups;\n}\n\n// Breadth First Search function\n// v is the source vertex\n// links is the input array, which contains all gantt relations\n// visited is a dictionary for keeping track of whether a node is visited\nfunction breadthFirstSearch(\n\tv: TaskID,\n\tlinks: IInternalLink[],\n\tvisited: IFlagHash\n): IConnectedGroupsDetailed {\n\tconst queue: TaskID[] = [v];\n\tconst groupTasks: TaskID[] = [];\n\tconst groupLinksInternal: { [hashSum: string]: IInternalLink } = {};\n\tconst groupLinksPublic: { [id: string]: boolean } = {};\n\n\tlet currentVertex: TaskID;\n\twhile (queue.length > 0) {\n\t\tcurrentVertex = queue.shift();\n\t\tif (!visited[currentVertex]) {\n\t\t\tvisited[currentVertex] = true;\n\t\t\tgroupTasks.push(currentVertex);\n\t\t\t// go through the input array to find vertices that are\n\t\t\t// directly adjacent to the current vertex, and put them\n\t\t\t// onto the queue\n\t\t\tfor (let i = 0; i < links.length; i++) {\n\t\t\t\tconst link = links[i];\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif ((link.source == currentVertex || link.sourceParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.target]) {\n\t\t\t\t\t\tqueue.push(link.target);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t} else if ((link.target == currentVertex || link.targetParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.source]) {\n\t\t\t\t\t\tqueue.push(link.source);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst linksArray: LinkID[] = [];\n\tconst linksObjects: IInternalLink[] = [];\n\tfor (const i in groupLinksPublic) {\n\t\tlinksArray.push(i);\n\t}\n\tfor (const i in groupLinksInternal) {\n\t\tlinksObjects.push(groupLinksInternal[i]);\n\t}\n\t// return everything in the current \"group\"\n\treturn { tasks: groupTasks, links: linksArray, processedLinks: linksObjects };\n}\n\nexport class ConnectedGroupsHelper {\n\tprivate _linksBuilder: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._gantt = gantt;\n\t}\n\n\tgetConnectedGroupRelations = (id: TaskID): IInternalLink[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tconst group = breadthFirstSearch(id, links, {});\n\t\treturn group.processedLinks;\n\t}\n\n\tgetConnectedGroup = (id: TaskID): IConnectedGroup | IConnectedGroup[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tif (id !== undefined) {\n\t\t\tif (this._gantt.getTask(id).type === this._gantt.config.types.project) {\n\t\t\t\treturn { tasks: [], links: [] };\n\t\t\t}\n\n\t\t\tconst group = breadthFirstSearch(id, links, {});\n\t\t\treturn {\n\t\t\t\ttasks: group.tasks,\n\t\t\t\tlinks: group.links\n\t\t\t};\n\t\t} else {\n\t\t\treturn findGroups(links).map(group => ({ tasks: group.tasks, links: group.links }));\n\t\t}\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AsapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AsapStrategy {\n\t\tconst instance = new AsapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\tresolveRelationDate(\n\t\ttaskId: TaskID,\n\t\tadjacentLinks: ITaskRelations,\n\t\tplansHash: IPlansHash\n\t): TaskPlan {\n\t\tlet minStart = null;\n\t\tlet linkId = null;\n\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.predecessors;\n\n\t\tlet minRelationDate = null;\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tconst constraintDate = this.getEarliestStartDate(\n\t\t\t\trelation,\n\t\t\t\tplansHash,\n\t\t\t\ttask\n\t\t\t);\n\n\t\t\tif (this.isSmallerOrDefault(minRelationDate, constraintDate, task)) {\n\t\t\t\tminRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tthis.isSmallerOrDefault(defaultStart, constraintDate, task) &&\n\t\t\t\tthis.isSmallerOrDefault(minStart, constraintDate, task)\n\t\t\t) {\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_start) {\n\t\t\tif (this.isSmallerOrDefault(task.start_date, this._gantt.config.project_start, task)) {\n\t\t\t\tminStart = this._gantt.config.project_start;\n\t\t\t}\n\t\t}\n\n\t\tlet maxEnd = null;\n\t\tif (minStart) {\n\t\t\tminStart = this._gantt.getClosestWorkTime({\n\t\t\t\tdate: minStart,\n\t\t\t\tdir: \"future\",\n\t\t\t\ttask\n\t\t\t});\n\t\t\tmaxEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minStart,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\tconst masterPlan = plansHash[taskId];\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.start_date = minStart;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.kind = \"asap\";\n\n\t\tif (minRelationDate) {\n\t\t\tcurrentPlan.earliestSchedulingStart = minRelationDate;\n\t\t\tcurrentPlan.earliestSchedulingEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minRelationDate,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn currentPlan;\n\t}\n\n\tprotected isEqual(dateA: Date, dateB: Date, task: ITask): boolean {\n\t\treturn !this._gantt._hasDuration(dateA, dateB, task);\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && !this.isEqual(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isSmallerOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t}\n\n\tprotected getPredecessorEndDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.end_date;\n\t\t} else if (plan.end_date) {\n\t\t\tres = plan.end_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: plan.start_date,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getEarliestStartDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask): Date {\n\t\tconst predecessorEnd = this.getPredecessorEndDate(\n\t\t\trelation.source,\n\t\t\tplansHash\n\t\t);\n\t\tconst successor = task;\n\n\t\tlet successorStart = this._gantt.getClosestWorkTime({\n\t\t\tdate: predecessorEnd,\n\t\t\tdir: \"future\",\n\t\t\ttask: successor\n\t\t});\n\n\t\tif (\n\t\t\tpredecessorEnd &&\n\t\t\trelation.lag &&\n\t\t\trelation.lag * 1 === relation.lag * 1\n\t\t) {\n\t\t\tsuccessorStart = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: predecessorEnd,\n\t\t\t\tduration: relation.lag * 1,\n\t\t\t\ttask: successor\n\t\t\t});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AlapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AlapStrategy {\n\t\tconst instance = new AlapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\n\tresolveRelationDate(taskId: TaskID, adjacentLinks: ITaskRelations, plansHash: IPlansHash): TaskPlan {\n\t\tlet maxEnd = null;\n\t\tlet linkId = null;\n\t\tlet maxStart = null;\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.successors;\n\t\tlet maxRelationDate = null;\n\t\tconst masterPlan = plansHash[taskId];\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\t\t\tconst constraintDate = this.getLatestEndDate(relation, plansHash, task);\n\t\t\tconst constraintStartDate = this._gantt.calculateEndDate({ start_date: constraintDate, duration: - task.duration, task });\n\n\t\t\tif (this.isGreaterOrDefault(maxRelationDate, constraintDate, task)) {\n\t\t\t\tmaxRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (this.isGreaterOrDefault(defaultStart, constraintStartDate, task) && this.isGreaterOrDefault(maxEnd, constraintDate, task)) {\n\t\t\t\tmaxEnd = constraintDate;\n\t\t\t\tmaxStart = constraintStartDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_end) {\n\t\t\tif (this.isGreaterOrDefault(this._gantt.config.project_end, task.end_date, task)) {\n\t\t\t\tmaxEnd = this._gantt.config.project_end;\n\t\t\t}\n\t\t}\n\n\t\tif (maxEnd) {\n\n\t\t\tmaxEnd = this._gantt.getClosestWorkTime({ date: maxEnd, dir: \"future\", task });\n\t\t\tmaxStart = this._gantt.calculateEndDate({ start_date: maxEnd, duration: - task.duration, task });\n\t\t}\n\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.start_date = maxStart;\n\t\tcurrentPlan.kind = \"alap\";\n\n\t\tif (maxRelationDate) {\n\t\t\tcurrentPlan.latestSchedulingStart = this._gantt.calculateEndDate({ start_date: maxRelationDate, duration: - task.duration, task });\n\t\t\tcurrentPlan.latestSchedulingEnd = maxRelationDate;\n\t\t}\n\n\t\treturn currentPlan;\n\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && this._gantt._hasDuration(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isGreaterOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(bigDate, smallDate, task));\n\t}\n\n\tprotected getSuccessorStartDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.start_date;\n\t\t} else if (plan.start_date) {\n\t\t\tres = plan.start_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({ start_date: plan.end_date, duration: - task.duration, task });\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getLatestEndDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask) {\n\t\tconst successorStart = this.getSuccessorStartDate(relation.target, plansHash);\n\t\tconst predecessor = task;\n\n\t\tlet predecessorEnd = this._gantt.getClosestWorkTime({ date: successorStart, dir: \"past\", task: predecessor });\n\n\t\tif (predecessorEnd && relation.lag && relation.lag * 1 === relation.lag * 1) {\n\t\t\tpredecessorEnd = this._gantt.calculateEndDate({ start_date: predecessorEnd, duration: -relation.lag * 1, task: predecessor });\n\t\t}\n\n\t\treturn predecessorEnd;\n\t}\n}","import { AlapStrategy } from \"./alap_strategy\";\nimport { AsapStrategy } from \"./asap_strategy\";\nimport { ConstraintTypes } from \"./constraint_types\";\nimport { ConstraintsHelper } from \"./constraints\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class AutoSchedulingPlanner {\n\tprivate _gantt: any;\n\tprivate _constraintsHelper: ConstraintsHelper;\n\tprivate _graphHelper: any;\n\tprivate _asapStrategy: AsapStrategy;\n\tprivate _alapStrategy: AlapStrategy;\n\n\tconstructor(\n\t\tgantt: any,\n\t\tgraphHelper: any,\n\t\tconstraintsHelper: ConstraintsHelper\n\t) {\n\t\tthis._gantt = gantt;\n\t\tthis._constraintsHelper = constraintsHelper;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._asapStrategy = AsapStrategy.Create(gantt);\n\t\tthis._alapStrategy = AlapStrategy.Create(gantt);\n\t}\n\n\tgeneratePlan(relations: IInternalLink[], constraints: ITask[]): TaskPlan[] {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst gantt = this._gantt;\n\t\tconst constraintsHelper = this._constraintsHelper;\n\t\tconst alapStrategy = this._alapStrategy;\n\t\tconst asapStrategy = this._asapStrategy;\n\n\t\tconst {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash } = this.buildWorkCollections(relations, constraints, graphHelper);\n\n\t\tlet result: TaskPlan[];\n\n\t\tthis.processConstraints(orderedIds, plansHash, gantt, constraintsHelper);\n\n\t\tif (gantt.config.schedule_from_end) {\n\t\t\t// when scheduling from end - iterate tasks from end and schedule them as late as possible\n\t\t\t// after that - iterate tasks from start and schedule asap tasks\n\t\t\tresult = this.iterateTasks(reversedIds, orderedIds, constraintsHelper.isAlapTask, alapStrategy, asapStrategy, relationsMap, plansHash);\n\t\t} else {\n\t\t\t// when scheduling from end - iterate tasks from start and schedule them as soon as possible\n\t\t\t// after that - iterate tasks from end and schedule asap alap\n\t\t\tresult = this.iterateTasks(orderedIds, reversedIds, constraintsHelper.isAsapTask, asapStrategy, alapStrategy, relationsMap, plansHash);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyProjectPlan(projectPlan: TaskPlan[]): ITask[] {\n\t\tconst gantt = this._gantt;\n\n\t\tlet plan: TaskPlan;\n\t\tlet task: ITask;\n\t\tlet link: ILink;\n\t\tlet reason: ITask;\n\n\t\tconst updateTasks = [];\n\t\tfor (let i = 0; i < projectPlan.length; i++) {\n\t\t\tlink = null;\n\t\t\treason = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif (!plan.task) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif (plan.link) {\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet newDate = null;\n\t\t\tif (\n\t\t\t\tplan.start_date &&\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf()\n\t\t\t) {\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif (!newDate) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [\n\t\t\t\ttask,\n\t\t\t\tnewDate,\n\t\t\t\tlink,\n\t\t\t\treason\n\t\t\t]);\n\t\t}\n\t\treturn updateTasks;\n\t}\n\n\tprotected iterateTasks(\n\t\tmainSequence: TaskID[],\n\t\tsecondarySequence: TaskID[],\n\t\tisMainSequence: (task: ITask) => boolean,\n\t\tmainSequenceStrategy: ISchedulingStrategy,\n\t\tsecondarySequenceStrategy: ISchedulingStrategy,\n\t\trelationsMap: ITaskLinksMap,\n\t\tplansHash: IPlansHash\n\n\t): TaskPlan[] {\n\t\tconst gantt = this._gantt;\n\t\tconst result: TaskPlan[] = [];\n\n\t\tfor (let i = 0; i < mainSequence.length; i++) {\n\t\t\tconst currentId = mainSequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\t\t\tconst plan = mainSequenceStrategy.resolveRelationDate(\n\t\t\t\tcurrentId,\n\t\t\t\trelationsMap[currentId],\n\t\t\t\tplansHash\n\t\t\t);\n\t\t\tthis.limitPlanDates(task, plan);\n\t\t\tif (isMainSequence(task)) {\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t} else {\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondarySequence.length; i++) {\n\t\t\tconst currentId = secondarySequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tif (!isMainSequence(task)) {\n\t\t\t\tconst plan = secondarySequenceStrategy.resolveRelationDate(\n\t\t\t\t\tcurrentId,\n\t\t\t\t\trelationsMap[currentId],\n\t\t\t\t\tplansHash\n\t\t\t\t);\n\t\t\t\tthis.limitPlanDates(task, plan);\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected processResolvedDate(\n\t\ttask: ITask,\n\t\tplan: TaskPlan,\n\t\tresult: TaskPlan[],\n\t\tplansHash: any\n\t): void {\n\t\tif (plan.start_date && this._gantt.isLinkExists(plan.link)) {\n\t\t\tlet link = null;\n\t\t\tlet reason = null;\n\t\t\tif (plan.link) {\n\t\t\t\tlink = this._gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf() &&\n\t\t\t\tthis._gantt.callEvent(\"onBeforeTaskAutoSchedule\", [\n\t\t\t\t\ttask,\n\t\t\t\t\tplan.start_date,\n\t\t\t\t\tlink,\n\t\t\t\t\treason\n\t\t\t\t]) === false\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tplansHash[task.id] = plan;\n\t\tif (plan.start_date) {\n\t\t\tresult.push(plan);\n\t\t}\n\t}\n\n\tprotected limitPlanDates(task: ITask, plan: TaskPlan): TaskPlan {\n\t\tconst effectiveStart = plan.start_date || task.start_date;\n\n\t\tif (plan.earliestStart) {\n\t\t\tif (effectiveStart < plan.earliestStart) {\n\t\t\t\tplan.start_date = plan.earliestStart;\n\t\t\t\tplan.end_date = plan.earliestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestStart) {\n\t\t\tif (effectiveStart > plan.latestStart) {\n\t\t\t\tplan.start_date = plan.latestStart;\n\t\t\t\tplan.end_date = plan.latestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestSchedulingStart && effectiveStart > plan.latestSchedulingStart) {\n\t\t\tplan.start_date = plan.latestSchedulingStart;\n\t\t\tplan.end_date = plan.latestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.earliestSchedulingStart && effectiveStart < plan.earliestSchedulingStart) {\n\t\t\tplan.start_date = plan.earliestSchedulingStart;\n\t\t\tplan.end_date = plan.earliestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.start_date) { // start/end dates are either both defined or both not\n\t\t\tif (plan.start_date > plan.latestSchedulingStart ||\n\t\t\t\tplan.start_date < plan.earliestSchedulingStart ||\n\t\t\t\tplan.start_date > plan.latestStart ||\n\t\t\t\tplan.start_date < plan.earliestStart ||\n\t\t\t\tplan.end_date > plan.latestSchedulingEnd ||\n\t\t\t\tplan.end_date < plan.earliestSchedulingEnd ||\n\t\t\t\tplan.end_date > plan.latestEnd ||\n\t\t\t\tplan.end_date < plan.earliestEnd) {\n\n\t\t\t\tplan.conflict = true;\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tprotected buildWorkCollections(relations: IInternalLink[], constraints: ITask[], graphHelper: any) {\n\t\tconst gantt = this._gantt;\n\t\tconst orderedIds: TaskID[] = graphHelper.topologicalSort(relations);\n\t\tconst reversedIds: TaskID[] = orderedIds.slice().reverse();\n\t\tconst plansHash: IPlansHash = {};\n\n\t\tconst relationsMap: ITaskLinksMap = {};\n\t\tfor (let i = 0, len = orderedIds.length; i < len; i++) {\n\t\t\tconst id = orderedIds[i];\n\t\t\tconst task = gantt.getTask(id);\n\t\t\tif (task.auto_scheduling === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trelationsMap[id] = {\n\t\t\t\tsuccessors: [],\n\t\t\t\tpredecessors: []\n\t\t\t};\n\n\t\t\tplansHash[id] = null;\n\t\t}\n\n\t\tfor (let i = 0, len = constraints.length; i < len; i++) {\n\t\t\tconst task = constraints[i];\n\n\t\t\tif (plansHash[task.id] === undefined) {\n\t\t\t\treversedIds.unshift(task.id);\n\t\t\t\torderedIds.unshift(task.id);\n\t\t\t\tplansHash[task.id] = null;\n\t\t\t\trelationsMap[task.id] = {\n\t\t\t\t\tsuccessors: [],\n\t\t\t\t\tpredecessors: []\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = relations.length; i < len; i++) {\n\t\t\tconst rel = relations[i];\n\t\t\tif (relationsMap[rel.source]) {\n\t\t\t\trelationsMap[rel.source].successors.push(rel);\n\t\t\t}\n\n\t\t\tif (relationsMap[rel.target]) {\n\t\t\t\trelationsMap[rel.target].predecessors.push(rel);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash\n\t\t};\n\t}\n\n\tprotected processConstraints(orderedIds: TaskID[], plansHash: IPlansHash, gantt: any, constraintsHelper: ConstraintsHelper) {\n\t\tfor (let i = 0; i < orderedIds.length; i++) {\n\t\t\tconst currentId = orderedIds[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tconst constraintType = constraintsHelper.getConstraintType(task);\n\t\t\tif (\n\t\t\t\tconstraintType &&\n\t\t\t\tconstraintType !== ConstraintTypes.ASAP &&\n\t\t\t\tconstraintType !== ConstraintTypes.ALAP\n\t\t\t) {\n\t\t\t\tconst plan = constraintsHelper.processConstraint(\n\t\t\t\t\ttask,\n\t\t\t\t\tTaskPlan.Create()\n\t\t\t\t);\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { ConstraintTypes } from \"./constraint_types\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class ConstraintsHelper {\n\tstatic Create(gantt: any): ConstraintsHelper {\n\t\treturn new ConstraintsHelper(gantt);\n\t}\n\n\tprivate _gantt: any;\n\tprivate constructor(gantt: any) {\n\t\tthis._gantt = gantt;\n\t}\n\n\tisAsapTask = (task: ITask): boolean => {\n\t\tconst constraintType = this.getConstraintType(task);\n\t\tif (this._gantt.config.schedule_from_end) {\n\t\t\tif (constraintType === ConstraintTypes.ASAP) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (constraintType === ConstraintTypes.ALAP) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tisAlapTask = (task: ITask): boolean => {\n\t\treturn !this.isAsapTask(task);\n\t}\n\n\tgetConstraintType = (task: ITask): ConstraintTypes => {\n\t\t// in case of backward scheduling, tasks without explicit constraints are considered ALAP tasks\n\t\tif (task.constraint_type) {\n\t\t\treturn task.constraint_type;\n\t\t} else if (this._gantt.config.schedule_from_end) {\n\t\t\treturn ConstraintTypes.ALAP;\n\t\t} else {\n\t\t\treturn ConstraintTypes.ASAP;\n\t\t}\n\t}\n\n\thasConstraint = (task: ITask): boolean => {\n\t\treturn !!this.getConstraintType(task);\n\t}\n\n\tprocessConstraint = (task: ITask, plan: TaskPlan): TaskPlan => {\n\t\tif (this.hasConstraint(task)) {\n\t\t\tif (\n\t\t\t\ttask.constraint_type === ConstraintTypes.ALAP ||\n\t\t\t\ttask.constraint_type === ConstraintTypes.ASAP\n\t\t\t) {\n\t\t\t\t// this kind of constraint is calculated after main scheduling\n\t\t\t} else {\n\t\t\t\tconst constraintDate = task.constraint_date;\n\n\t\t\t\tconst newPlan = TaskPlan.Create(plan);\n\t\t\t\tnewPlan.task = task.id;\n\n\t\t\t\tswitch (task.constraint_type) {\n\t\t\t\t\tcase ConstraintTypes.SNET:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.SNLT:\n\t\t\t\t\t\tnewPlan.latestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.latestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.latestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNET:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNLT:\n\t\t\t\t\t\tnewPlan.latestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MSO:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MFO:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn newPlan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan;\n\t}\n\n\tgetConstraints = (id: TaskID, relations: IInternalLink[]): ITask[] => {\n\t\tconst result = [];\n\t\tconst tasks = {};\n\n\t\tconst store = (task: any) => {\n\t\t\tif (tasks[task.id]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasConstraint(task) && !this._gantt.isSummaryTask(task)) {\n\t\t\t\ttasks[task.id] = task;\n\t\t\t}\n\t\t};\n\n\t\tif (this._gantt.isTaskExists(id)) {\n\t\t\tconst task = this._gantt.getTask(id);\n\t\t\tstore(task);\n\t\t}\n\n\t\tthis._gantt.eachTask(task => store(task), id);\n\n\t\tlet current;\n\t\tif (relations) {\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst rel = relations[i];\n\t\t\t\tif (!tasks[rel.target]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.target);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t\tif (!tasks[rel.source]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.source);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const taskId in tasks) {\n\t\t\tresult.push(tasks[taskId]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","require(\"../core/relations/links_common\")(gantt);\n\nvar linksBuilder = require(\"../core/relations/links_builder\")(gantt);\nvar graphHelper = require(\"../core/relations/graph_helper\")(gantt);\nvar ConstraintTypes = require(\"./auto_scheduling/constraint_types\").ConstraintTypes;\n\nvar constraintsHelper = require(\"./auto_scheduling/constraints\").ConstraintsHelper.Create(\n\tgantt\n);\nvar AutoSchedulingPlanner = require(\"./auto_scheduling/planner\")\n\t.AutoSchedulingPlanner;\n\nvar planner = new AutoSchedulingPlanner(gantt, graphHelper, constraintsHelper);\n\nvar ConnectedGroupsHelper = require(\"./auto_scheduling/connected_groups\")\n\t.ConnectedGroupsHelper;\nvar connectedGroups = new ConnectedGroupsHelper(gantt, linksBuilder);\n\nvar LoopsFinder = require(\"./auto_scheduling/loops_finder\").LoopsFinder;\n\nvar loopsFinder = new LoopsFinder(\n\tgantt,\n\tgraphHelper,\n\tlinksBuilder\n);\n\ngantt.getConnectedGroup = connectedGroups.getConnectedGroup;\ngantt.getConstraintType = constraintsHelper.getConstraintType;\ngantt.getConstraintLimitations = function (task) {\n\tvar plan = constraintsHelper.processConstraint(task, null);\n\treturn {\n\t\tearliestStart: plan.earliestStart || null,\n\t\tearliestEnd: plan.earliestEnd || null,\n\t\tlatestStart: plan.latestStart || null,\n\t\tlatestEnd: plan.latestEnd || null\n\t};\n};\n\ngantt.isCircularLink = loopsFinder.isCircularLink;\ngantt.findCycles = loopsFinder.findCycles;\n\ngantt.config.constraint_types = ConstraintTypes;\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\ngantt.config.project_start = null;\ngantt.config.project_end = null;\ngantt.config.schedule_from_end = false;\n\nfunction preferInitialTaskDates(startTask, relations) {\n\t// TODO: remove in 7.0\n\tif (!gantt.config.auto_scheduling_compatibility) {\n\t\treturn;\n\t}\n\n\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t// will be removed in future versions\n\tfor (var i = 0; i < relations.length; i++) {\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif (!gantt.config.auto_scheduling_strict || rel.target == startTask) {\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n}\n\nfunction updateParentsAndCallEvents(updatedTasks) {\n\tfunction resetTime(task) {\n\t\tif (batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif (task.start_date.valueOf() != start || task.end_date.valueOf() != end) {\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor (var i = 0; !batchUpdate && i < children.length; i++) {\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif (updatedTasks.length == 1) {\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t} else if (updatedTasks.length) {\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload() {\n\t\tfor (var i = 0; i < updatedTasks.length; i++) {\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif (batchUpdate) {\n\t\tgantt.batchUpdate(payload);\n\t} else {\n\t\tpayload();\n\t}\n}\n\ngantt._autoSchedule = function (id, relations) {\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar constraints = constraintsHelper.getConstraints(\n\t\tid,\n\t\tgantt.isTaskExists(id) ? relations : null\n\t);\n\n\tvar updatedTasks = [];\n\n\tvar cycles = graphHelper.findLoops(relations);\n\tif (cycles.length) {\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t} else {\n\t\tpreferInitialTaskDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations, constraints);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tupdateParentsAndCallEvents(updatedTasks);\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n};\n\ngantt.autoSchedule = function (id, inclusive) {\n\tif (inclusive === undefined) {\n\t\tinclusive = true;\n\t} else {\n\t\tinclusive = !!inclusive;\n\t}\n\n\tvar relations;\n\tif (id !== undefined) {\n\t\tif (gantt.config.auto_scheduling_compatible) {\n\t\t\tlinksBuilder.getLinkedTasks(id, inclusive);\n\t\t} else {\n\t\t\trelations = connectedGroups.getConnectedGroupRelations(id);\n\t\t}\n\t} else {\n\t\trelations = linksBuilder.getLinkedTasks();\n\t}\n\n\tgantt._autoSchedule(id, relations);\n};\n\ngantt.attachEvent(\"onTaskLoading\", function (task) {\n\tif (task.constraint_date && typeof task.constraint_date === \"string\") {\n\t\ttask.constraint_date = gantt.date.parseDate(task.constraint_date, \"parse_date\");\n\t}\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\ngantt.attachEvent(\"onTaskCreated\", function (task) {\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\n\nvar attachUIHandlers = require(\"./auto_scheduling/ui_handlers\").attachUIHandlers;\nattachUIHandlers(gantt, linksBuilder, loopsFinder, connectedGroups);\n","export class TaskPlan implements ITaskPlan {\n\tstatic Create(parent?: TaskPlan): TaskPlan {\n\t\tconst plan = new TaskPlan();\n\t\tif (parent) {\n\t\t\tfor (const i in plan) {\n\t\t\t\tif (parent[i] !== undefined) {\n\t\t\t\t\tplan[i] = parent[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tpublic link: string | number;\n\tpublic task: string | number;\n\t// tslint:disable-next-line variable-name\n\tpublic start_date: Date | null;\n\t// tslint:disable-next-line variable-name\n\tpublic end_date: Date | null;\n\n\tpublic latestStart: Date;\n\tpublic earliestStart: Date;\n\tpublic earliestEnd: Date;\n\tpublic latestEnd: Date;\n\n\tpublic latestSchedulingStart: Date;\n\tpublic earliestSchedulingStart: Date;\n\tpublic latestSchedulingEnd: Date;\n\tpublic earliestSchedulingEnd: Date;\n\n\tpublic kind: string;\n\tpublic conflict: boolean;\n\n\tconstructor() {\n\t\tthis.link = null;\n\t\tthis.task = null;\n\t\tthis.start_date = null;\n\t\tthis.end_date = null;\n\t\tthis.latestStart = null;\n\t\tthis.earliestStart = null;\n\t\tthis.earliestEnd = null;\n\t\tthis.latestEnd = null;\n\t\tthis.latestSchedulingStart = null;\n\t\tthis.earliestSchedulingStart = null;\n\t\tthis.latestSchedulingEnd = null;\n\t\tthis.earliestSchedulingEnd = null;\n\t\tthis.kind = \"asap\";\n\t\tthis.conflict = false;\n\t}\n}"],"sourceRoot":""}